#version 330

in vec4 EyeCoords;
in vec3 Normal;
in vec2 TexCoords;

uniform vec3 viewPos;            // Camera position
uniform sampler2D texture1;      // Texture sampler

// Sunlight properties
uniform vec3 sunlightDir;        // Direction of sunlight (normalized)
uniform vec3 sunlightColor;      // Color of sunlight
uniform float ambientIntensity;       // Ambient light intensity

// Underwater light attenuation
uniform float waterDepth;        // Maximum depth for attenuation
uniform vec3 waterColor;         // Water color for light absorption
uniform float lightDecay;        // Light decay factor underwater

void main() {
    // Normalize the normal vector
    vec3 norm = normalize(Normal);

    // Compute diffuse lighting (Lambertian reflection)
    float diff = max(dot(-sunlightDir, norm), 0.0);
    vec3 diffuse = diff * sunlightColor;

    // Compute view direction and specular highlights (Phong reflection)
    vec3 viewDir = normalize(viewPos - EyeCoords.xyz);
    vec3 reflectDir = reflect(sunlightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); // Shininess factor
    vec3 specular = spec * sunlightColor;

    // Compute depth-based attenuation
    float depthFactor = clamp((EyeCoords.y + waterDepth) / waterDepth, 0.0, 1.0);
    vec3 attenuatedLight = mix(waterColor, sunlightColor, depthFactor) * exp(-lightDecay * (1.0 - depthFactor));

    const vec3 baseAmbientColor = vec3(0.3, 0.3, 0.4); // Base ambient color

    // Combine ambient, diffuse, and specular lighting with attenuation
    vec3 lighting = baseAmbientColor * ambientIntensity + (diffuse + specular) * 1.f;

    // Sample the texture color and apply lighting
    vec4 texColor = texture(texture1, TexCoords);
    // gl_FragColor = vec4(lighting * texColor.rgb, texColor.a);
    gl_FragColor = vec4(vec3(diff) * texColor.rgb, 1.0); // Diffuse contribution as grayscale

}
